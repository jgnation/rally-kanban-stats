<!DOCTYPE html>
<html>
<head>
    <title>exclusions</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                
Ext.Loader.setConfig({
    enabled:        true,
    disableCaching: true,
    paths: {
        'Ext.ux':  'ux'
    }
});

Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    items:{ html:'<a href="https://help.rallydev.com/apps/2.0rc3/doc/">App SDK 2.0rc3 Docs</a>'},
    launch: function() {

		this.excludedDates = [];

		//create initial widgits
		this._createContainers();
        this._createDateFields();
		this._createMultiDateCalendar();
    },

    /*
     * Establish the layout of the screen
     */
    _createContainers: function() {
		//this container will contain the topLeftContainer and topRightContainer
		this.topContainer = Ext.create('Ext.container.Container', {
			title: 'Top',
			flex: 1,
			layout: {
				type: 'hbox', // 'horizontal' layout
				align: 'stretch'
			}
		});
		this.add(this.topContainer);

		//this will contain the date fields and get report button
		this.topLeftContainer = Ext.create('Ext.container.Container', {
			title: 'TopLeft',
			flex: .30,
			layout: {
				type: 'vbox',
				align: 'stretch'
			}
		});
		this.topContainer.add(this.topLeftContainer);

		//this will contain the statistics grid
		this.topCenterContainer = Ext.create('Ext.container.Container', {
			title: 'TopCenter',
			flex: .20,
			layout: {
				type: 'vbox',
				align: 'stretch'
			}
		});
		this.topContainer.add(this.topCenterContainer);

		//this will contain the chart
		this.topRightContainer = Ext.create('Ext.container.Container', {
			title: 'TopRight',
			flex: .30,
			layout: {
				type: 'vbox',
				align: 'stretch'
			}
		});
		this.topContainer.add(this.topRightContainer);

		//this container will contain the grid
		this.bottomContainer = Ext.create('Ext.container.Container', {
			title: 'Bottom',
			flex: 2,
			layout: {
				align: 'stretch'
			}
		});
		this.add(this.bottomContainer);
    },

    _createDateFields: function() {
		var start = Ext.create('Ext.Container', {
			items: [{
				xtype: 'rallydatefield',
				fieldLabel: 'Start Date',
				value: this.startDate = new Date(),
				listeners: {
					change: function(start, newValue, oldValue, eOpts) {
						this.startDate = newValue;
					},
					scope: this
				}
			}],
			renderTo: Ext.getBody().dom
		});

		var end = Ext.create('Ext.Container', {
			items: [{
				xtype: 'rallydatefield',
				fieldLabel: 'End Date',
				value: this.endDate = new Date(),
				listeners: {
					change: function(start, newValue, oldValue, eOpts) {
						this.endDate = newValue;
					},
					scope: this
				}
			}],
			renderTo: Ext.getBody().dom
		});

		this.topLeftContainer.add(start);
		this.topLeftContainer.add(end);
	},

	_createMultiDateCalendar:function() {
    	var calendar = Ext.create('MultiDateCalendarPanel');
    	var panel = calendar._create(this);

		this.topLeftContainer.add(panel);
    },

    /*
     * Called by the 'Get Report' button handler (see MultiDateCalendarPanel.js)
     */
    _runReport: function() {
	    var sDate = Rally.util.DateTime.toIsoString(this.startDate);
		var eDate = Rally.util.DateTime.toIsoString(this.endDate);
		this._loadData(sDate, eDate);
    },

    /*
     * Query the Rally wsapi
     */
	_loadData: function(startDate, endDate) {
		var storeFilters = [
				{
					property: 'ScheduleState',
					operation: '=',
					value: 'Accepted'
				},
				{
					property: 'DirectChildrenCount',
					operation: '=',
					value: '0'
				},
				{
					//property: 'InProgressDate',
					property: 'AcceptedDate',
					operator: '>=',
					value: startDate
				},
				{
					property: 'AcceptedDate',
					operator: '<=',
					value: endDate
				}
			];

		if (this.myStore) {
			this.myStore.setFilter(storeFilters);
			this.myStore.load();
		} else {
			var store = Ext.create('MainStore');
    		this.myStore = store._create(this, storeFilters);			
		}
    },

    /*
     * Called when the query to the Rally wsapi returns (see MainStore.js)
     */
    _loadGrid: function(myStoryStore, records) {

    	if (this.customGridStore) {
    		this.customGridStore.loadRawData(records);
    	} else {
    		this.customGridStore = Ext.create('Rally.data.custom.Store', {
    			fields: ['FormattedID', 'Name', 'DaysInProgress', 'DaysInProgressExclusions', 'InProgressDate', 'AcceptedDate'],
				data: records
			});

			var mainGrid = Ext.create('MainGrid');
			this.myGrid = mainGrid._create(this);

			this.bottomContainer.add(this.myGrid);
    	}
    },

    /*
     * Called when the query to the Rally wsapi returns (see MainStore.js)
     */
    _createChart: function(records) {
    	var chart = Ext.create('Chart');

   		var data = chart._recordsToChartData(records);

   		if (this.chartStore) {
   			this.chartStore.loadRawData(data);
   		} else {
			this.chartStore = Ext.create('Ext.data.JsonStore', {
			    fields: ['name', 'data'],
			    data: data
			});

    		this.chart = chart._create(this);
			
			this.topRightContainer.add(this.chart);
		}

	   	if (records.length > 0)	this.topRightContainer.setVisible(true);
		else this.topRightContainer.setVisible(false);

		this._createCenterGrid(data, records);
    },

    /*
     * Creates a grid to accompany the chart (see this._createChart())
     */
    _createCenterGrid: function(data, records) {
	    var centerGrid = Ext.create('CenterGrid');
		centerGrid._addTotalStories(data);
		centerGrid._addAverageDays(data, records);


		if (this.centerGridStore) {
			this.centerGridStore.loadRawData(data);
		} else {
			this.centerGridStore = Ext.create('Rally.data.custom.Store', {
				fields: ['name', 'data'],
	    	 	data: data
	    	});

			this.centerGrid = centerGrid._create(this);
			this.topCenterContainer.add(this.centerGrid);
		}

		if (records.length > 0)	this.topCenterContainer.setVisible(true);
		else this.topCenterContainer.setVisible(false);
    }
});

/*
TODO:
-----
-add links to story in main grid
-fix jumpy chart
-prefix 'private' methods with an underscore, public without
-sort grid results?
-add ability to see a chart with exclusions and without.  Switch between them with a radio button.
-fix multidate calendar error by extending the object rather than editing the code
-https://github.com/nohuhu/Ext.ux.form.field.MultiDate
*/

                /*
 * Mixin that allows multiple values or ranges of values of the same type to be entered in
 * a field.
 *
 * Version 0.99, compatible with Ext JS 4.1.
 *  
 * Copyright (c) 2011-2012 Alexander Tokarev.
 *  
 * This code is licensed under the terms of the Open Source LGPL 3.0 license.
 * Commercial use is permitted to the extent that the code/component(s) do NOT
 * become part of another Open Source or Commercially licensed development library
 * or toolkit without explicit permission.
 * 
 * License details: http://www.gnu.org/licenses/lgpl.html
 */

Ext.define('Ext.ux.form.field.MultiValue', {
    /**
     * @private Mixin indicator.
     */
    isMultiValued: true,
    
    /**
     * @cfg {Boolean} [multiValue=false] Determines if multiple values are allowed in
     * the field.
     */
    multiValue: false,
    
    /**
     * @cfg {RegExp} valueSeparator Regular expression used to separate input values
     * from each other.
     */
    valueSeparatorRE: /[;,]\s*/,
    
    /**
     * @cfg {RegExp} rangeSeparator Regular expression used to separate start and end
     * of a range.
     */
    rangeSeparatorRE: /\s*-\s*/,

    /**
     * @cfg {RegExp} valuePattern Regular expression used to validate one value or
     * part of a range.
     */
    valuePatternRE: /\d+/,
    
    /**
     * @cfg {String} displayValueSeparator Character or string used to separate
     * displayed values from each other. It may differ from both valueSeparator regex
     * and submitValueSeparator.
     */
	displayValueSeparator: ', ',
	
	/**
	 * @cfg {String} displayRangeSeparator Character or string used to denote a range
	 * of values when displaying. It is placed between range start and end.
	 */
	displayRangeSeparator: '-',
    
    /**
     * @cfg {String} submitValueSeparator Character or string used to separate
     * submitted values from each other. It may differ from valueSeparator regex.
     */
    submitValueSeparator: ';',
    
    /**
     * @cfg {String} submitRangeSeparator Character or string used to denote a range;
     * it is placed between range start and end upon submitting values.
     */
    submitRangeSeparator: '-',
    
    constructor: function(config) {
        var me = this,
            config = config || {};
        
        Ext.apply(me, config);
        
        me.regex = me.multiValue ? me.initMultiRegex()
                 :                 me.initSingleRegex()
                 ;
        
        me.callParent(arguments);
    },
    
    /**
     * @private Creates regex for checking single value when multiValue is off.
     */
    initSingleRegex: function() {
        var me = this,
            value;
        
        value = me.valueRegex();
        
        return new RegExp( '^' + value + '$' );
    },
    
    /**
     * @private Creates regex for checking multiple values and ranges when multiValue is on.
     */
    initMultiRegex: function() {
        var me = this,
            value, vsep, rsep, range, valueOrRange;
        
        value = me.valueRegex();
        
        // Normalize regexen
        me.rangeSeparatorRE = new RegExp(me.rangeSeparatorRE);
        me.valueSeparatorRE = new RegExp(me.valueSeparatorRE);
        
        rsep  = me.rangeSeparatorRE.source;
        vsep  = me.valueSeparatorRE.source;
        
        range = value + rsep + value;
        valueOrRange = '(' + value + '|' + range + ')';
        
        return new RegExp(
            '^' +
                '(' + valueOrRange + ')'
                +
                '(' + vsep + valueOrRange + ')*'
                +
            '$'
        );
    },
    
    /**
     * @private Normalizes single value regex.
     */
    valueRegex: function() {
        var me = this,
            vp;
            
        me.valuePatternRE = vp = new RegExp(me.valuePatternRE);
        
        return vp.source;
    },
    
    /**
     * @private Formats single value for submission.
     */
    formatSubmitValue: function(value) {
        // Does nothing in mixin
        return value;
    },
    
    /**
     * @private Formats single range of values for submission.
     */
    formatSubmitRange: function(range, rsep) {
        var me = this,
            start, end;

        start = me.formatSubmitValue( range[0] );
        end   = me.formatSubmitValue( range[1] );
        
        return start + rsep + end;
    },
    
    /**
     * @private Formats current values as a string for submission.
     */
    formatSubmit: function(values, rsep, vsep) {
        var me = this,
            multi = me.multiValue,
            valsep = me.valueSeparatorRE,
            ransep = me.rangeSeparatorRE,
            items, isStr, doesMatch;
        
        items = me.splitValues(values, valsep);
        
        for ( var i = 0, l = items.length; i < l; i++ ) {
            var item = items[i],
                vr;
                
            vr = me.splitValues(item, ransep);
            
            items[i] = vr.length > 1 ? me.formatSubmitRange(vr, rsep || me.submitRangeSeparator)
                     :                 me.formatSubmitValue(vr)
                     ;
        };
        
        values = items.join(vsep || me.submitValueSeparator);
        
        return values;
    },
    
    /**
     * @private Splits string of values using provided normalized regex.
     * Always returns an array.
     */
    splitValues: function(values, regex) {
        var me = this;
        
        return me.multiValue && Ext.isString(values) &&
               regex.source !== '' && values.match(regex)   ? values.split(regex)
             :                                                [ values ]
             ;
    },

    /**
     * @private Formats single value for displaying in input field.
     */
    formatDisplayValue: function(value) {
        return Ext.isString(value) ? value : value.toString();  // Trying to be generic
    },
    
    /**
     * @private Formats single range of values for displaying in input field.
     */
    formatDisplayRange: function(range, rsep) {
        var me = this,
            start, end;
        
        start = me.formatDisplayValue( range[0] );
        end   = me.formatDisplayValue( range[1] );
        
        return start + rsep + end;
    },
    
    /**
     * @private Formats array of values for displaying in input field. This method is mostly
     * useful for using with pickers that return raw objects and arrays of objects.
     */
    formatDisplay: function(values, rsep, vsep) {
        var me = this,
            multi = me.multiValue,
            results = [];
        
        if ( !multi ) {
            return me.formatDisplayValue(values[0]);
        };
        
        for ( var i = 0, l = values.length; i < l; i++ ) {
            var value = values[i];
            
            if ( Ext.isArray(value) ) {
                results.push( me.formatDisplayRange(value, rsep || me.displayRangeSeparator) );
            }
            else {
                results.push( me.formatDisplayValue(value) );
            };
        };
        
        return results.join(vsep || me.displayValueSeparator);
    }
});
                /*
 * Date picker with support for multiple selections.
 *
 * Version 0.99, compatible with Ext JS 4.1.
 *  
 * Copyright (c) 2011-2012 Alexander Tokarev.
 *  
 * This code is licensed under the terms of the Open Source LGPL 3.0 license.
 * Commercial use is permitted to the extent that the code/component(s) do NOT
 * become part of another Open Source or Commercially licensed development library
 * or toolkit without explicit permission.
 * 
 * License details: http://www.gnu.org/licenses/lgpl.html
 */

Ext.define('Ext.ux.picker.MultiDate', {
    extend: 'Ext.picker.Date',
    alias:  'widget.multidatepicker',
    
    alternateClassName: [ 'Ext.picker.MultiDate', 'Ext.MultiDatePicker' ],
    
    renderTpl: [
        '<div class="{cls}" id="{id}-innerEl" role="grid">',
            '<div role="presentation" class="{baseCls}-header">',
                //'<div class="{baseCls}-prev"><a id="{id}-prevEl" href="#" role="button" title="{prevText}"></a></div>',
                '<a id="{id}-prevEl" class="{baseCls}-prev {baseCls}-arrow" href="#" role="button" title="{prevText}" hidefocus="on" ></a>',
                '<div class="{baseCls}-month" id="{id}-middleBtnEl">{%this.renderMonthBtn(values, out)%}</div>',
               // '<div class="{baseCls}-next"><a id="{id}-nextEl" href="#" role="button" title="{nextText}"></a></div>',
                '<a id="{id}-nextEl" class="{baseCls}-next {baseCls}-arrow" href="#" role="button" title="{nextText}" hidefocus="on" ></a>',

            '</div>',
            '<table id="{id}-eventEl" class="u{baseCls}-inner" cellspacing="0" role="presentation">',
                '<thead role="presentation"><tr role="presentation">',
                    '<tpl for="dayNames">',
                        '<th role="columnheader" title="{.}"><span>{.:this.firstInitial}</span></th>',
                    '</tpl>',
                '</tr></thead>',
                '<tbody role="presentation"><tr role="presentation">',
                    '<tpl for="days">',
                        '{#:this.isEndOfWeek}',
                        '<td role="gridcell" id="{[Ext.id()]}">',
                            '<a role="presentation" href="#" hidefocus="on" class="{parent.baseCls}-date" tabIndex="1">',
                                '<em role="presentation"><span role="presentation"></span></em>',
                            '</a>',
                        '</td>',
                    '</tpl>',
                '</tr></tbody>',
            '</table>',
            '<div id="{id}-footerEl" role="presentation" class="{baseCls}-footer">',
                '<tpl if="this.showToday">',
                    '{%this.renderTodayBtn(values, out)%}',
                '<tpl else>',
                    '{%this.renderOkBtn(values, out)%}',
                    '{%this.renderCancelBtn(values, out)%}',
                    '{%this.renderClearBtn(values, out)%}',
                '</tpl>',
            '</div>',
        '</div>',
        {
            firstInitial: function(value) {
                return Ext.picker.Date.prototype.getDayInitial(value);
            },
            isEndOfWeek: function(value) {
                // convert from 1 based index to 0 based
                // by decrementing value once.
                value--;
                var end = value % 7 === 0 && value !== 0;
                return end ? '</tr><tr role="row">' : '';
            },
            renderTodayBtn: function(values, out) {
                Ext.DomHelper.generateMarkup(values.$comp.todayBtn.getRenderTree(), out);
            },
            renderOkBtn: function(values, out) {
                Ext.DomHelper.generateMarkup(values.$comp.okBtn.getRenderTree(), out);
            },
            renderCancelBtn: function(values, out) {
                Ext.DomHelper.generateMarkup(values.$comp.cancelBtn.getRenderTree(), out);
            },
            renderClearBtn: function(values, out) {
                Ext.DomHelper.generateMarkup(values.$comp.clearBtn.getRenderTree(), out);
            },
            renderMonthBtn: function(values, out) {
                Ext.DomHelper.generateMarkup(values.$comp.monthBtn.getRenderTree(), out);
            }
        }
    ],
    
    nextText:      Ext.isMac ? 'Next Month (&#x2318;&#x2192;)' : 'Next Month (Control+Right)',
    prevText:      Ext.isMac ? 'Previous Month (&#x2318&#x2190;)' : 'Previous Month (Control+Left)',
    monthYearText: Ext.isMac ? 'Choose a month (&#x2318 + &#x2191;/&#x2193; to move years)' : 'Choose a month (Control+Up/Down to move years)',
    
    /**
     * @cfg {String} okText OK button text.
     */
    okText:        'OK',
    
    /**
     * @cfg {String} okTooltip OK button tooltip text.
     */
    okTooltip:     Ext.isMac ? 'Confirm selection (⏎)' : 'Confirm selection (Enter)',
    
    /**
     * @cfg {String} cancelText Cancel button text.
     */
    cancelText:    'Cancel',
    
    /**
     * @cfg {String} cancelTooltip Cancel button tooltip text.
     */
    cancelTooltip: Ext.isMac ? 'Cancel selection (⎋)' : 'Cancel selection (Escape)',
    
    /**
     * @cfg {String} clearText 'Clear selection' button text.
     */
    clearText:     'Clear',
    
    /**
     * @cfg {String} clearTooltip 'Clear selection' button tooltip text.
     */
    clearTooltip:  Ext.isMac ? 'Clear selection (⌘⌫)' : 'Clear selection (Ctrl+Backspace)',
    
    /**
     * @cfg {Int[]/Boolean} workDays Array of 0-based week day numbers that represent
     * work week for given locale. Defaults to Monday-Friday. Set to 'false' to turn
     * this feature off.
     */
    workDays: [ 1, 2, 3, 4, 5 ],
    
    showToday: false,
    
    initComponent: function() {
        var me = this,
            wd = me.workDays;
        
        me.callParent(arguments);
        
        // Active cell class is different
        me.activeCls = 'ux-datepicker-active';
        
        me.selDates = [];
        
        if ( wd && Ext.isArray(wd) ) {
            var hash = {
                0: false, 1: false, 2: false, 3: false, 4: false, 5: false, 6: false
            };
            
            for ( var i = 0, l = wd.length; i < l; i++ ) {
                hash[ wd[i] ] = true;
            };
            
            me.workDaysHash = hash;
        }
        else {
            me.workDaysHash = {
                0: true, 1: true, 2: true, 3: true, 4: true, 5: true, 6: true
            };
        };
    },
    
    beforeRender: function() {
        var me = this;
        
        me.callParent(arguments);
        
        if ( !me.showToday ) {
            Ext.destroy(me.todayBtn);

            var layout = me.getComponentLayout();
        
            me.okBtn = new Ext.button.Button({
                ownerCt:     me,
                ownerLayout: layout,
                text:        me.okText,
                tooltip:     me.okTooltip,
                handler:     me.onOkButton,
                scope:       me
            });
            
            me.cancelBtn = new Ext.button.Button({
                ownerCt:     me,
                ownerLayout: layout,
                text:        me.cancelText,
                tooltip:     me.cancelTooltip,
                handler:     me.onCancelButton,
                scope:       me
            });
            
            me.clearBtn = new Ext.button.Button({
                ownerCt:     me,
                ownerLayout: layout,
                text:        me.clearText,
                tooltip:     me.clearTooltip,
                handler:     me.clearSelection,
                scope:       me
            });
        };
    },
    
    finishRenderChildren: function() {
        var me = this;
        
        me.callParent();
        
        if ( !me.showToday ) {
            me.okBtn.finishRender();
            me.cancelBtn.finishRender();
            me.clearBtn.finishRender();
        };
    },
    
    initEvents: function() {
        var me = this,
            evEl = me.eventEl;
        
        me.callParent(arguments);
        
        // Override default key handlers
        evEl.addKeyListener(Ext.EventObject.ENTER, me.onOkButton,     me);
        evEl.addKeyListener(Ext.EventObject.ESC,   me.onCancelButton, me);
        evEl.addKeyListener(Ext.EventObject.SPACE, me.handleSpacebar, me);
        evEl.addKeyListener({ key: Ext.EventObject.BACKSPACE, ctrl: true }, me.clearSelection, me);
    },
    
    /**
     * @private Assigns values and refreshes the picker.
     */
    setValue: function(values) {
        var me = this;
        
        function getClearTime(d) { return Ext.Date.clearTime(d).getTime() };
        
        me.selDates = Ext.isArray(values) ? Ext.Array.map(values, getClearTime)
                    :                      [ getClearTime(values) ]
                    ;
        
        //me.update(me.selDates);
        me.update(values);
    },
    
    /**
     * @private Returns current selection range.
     */
    getValue: function() {
        var me = this;
        
        return Ext.Array.map(me.selDates, function(t) { return new Date(t) });
    },
    
    onOkButton: function() {
        var me = this,
            handler = me.handler;
        
        if ( !me.disabled ) {
            var value = me.getValue();
            
            me.fireEvent('select', me, value);
        
            if ( handler ) {
                handler.call(me.scope || me, me, value);
            };
            
            me.onSelect();
            me.clearSelection();
        };
    },
    
    onCancelButton: function() {
        var me = this;
        
        me.clearSelection();
        me.pickerField.collapse();
    },
    
    clearSelection: function() {
        var me = this,
            cells = me.cells,
            aCls = me.activeCls,
            sCls = me.selectedCls;
        
        // Clear the selection
        me.selDates = [];
        me.rangeSelection = false;
        cells.removeCls(aCls);
        cells.removeCls(sCls);
        
        me.update(Ext.Date.clearTime( new Date() ));
    },

    handleDateClick : function(event, target) {
        var me = this,
            selDates = me.selDates,
            el, dv, dt;

        event.stopEvent();
        
        el = Ext.fly(target.parentElement);
        dv = target.dateValue;
        
        if ( event.shiftKey && !event.ctrlKey ) {           // Select work week
            dt = me.toggleWeekSelection(el);
        }
        else if ( event.ctrlKey ) {        // Select range or work range (no toggling)
            if ( !me.rangeSelection ) {    // Start selection
                me.rangeSelection = dv;
                dt = me.toggleDateSelection(el, true, dv);
            }
            else {          // End selection
               dt = me.selectRange(me.rangeSelection, dv, event.shiftKey);
               me.rangeSelection = false;
            };
        }
        else {                                      // Select single day
            dt = me.toggleDateSelection(el, undefined, dv);
        };
        
        if ( dt ) {
            me.update(selDates);
        };
        
        // Set active date, too
        me.update( new Date(dv) );
    },

    handleSpacebar: function(keycode, event) {
        var me       = this,
            selDates = me.selDates,
            cells    = me.cells,
            activeDate, activeCell, activeIdx, dt;
        
        activeDate = me.activeDate.getTime();
        activeIdx  = me.getCellIndex(activeDate);
        
        if ( activeIdx == -1 ) {
            return;
        };
        
        activeCell = cells.item(activeIdx);
        
        dt = event.shiftKey ? me.toggleWeekSelection(activeCell, activeIdx)
           :                  me.toggleDateSelection(activeCell, undefined, activeDate)
           ;
        
        if ( dt ) {
            me.update(selDates);
        };
    },
    
    /**
     * @private Returns cell index by date value.
     */
    getCellIndex: function(value) {
        var me = this,
            cells = me.cells,
            index;
            
        // This is suboptimal but I don't know a way to do it otherwise
        // without affecting me.cells.
        cells.each(function(el, c, idx) {
            if ( !index && el.down('a').getAttribute('dateValue') === value ) {
                index = idx;
            };
        });
        
        return index === undefined ? -1 : index;
    },
    
    selectRange: function(start, end, workWeek) {
        var me       = this,
            selDates = me.selDates,
            wdHash   = me.workDaysHash,
            add      = Ext.Date.add,
            DAY      = Ext.Date.DAY,
            contains = Ext.Array.contains,
            include  = Ext.Array.include,
            tmp, dt, dv;
        
        // JS is ugly.
        if ( start > end ) {
            tmp   = start;
            start = end;
            end   = tmp;
        };
        
        // If start date falls on a weekend we shouldn't allow it
        // to be selected
        Ext.Array.remove( selDates, new Date(start).getTime() );
        
        DATE:
        for ( dt = new Date(start), dv = dt.getTime();
              dv <= end;
              dt = add(dt, DAY, 1), dv = dt.getTime() )
        {
            if ( workWeek && !wdHash[ dt.getDay() ] ) {
                continue DATE;
            };
            
            include(selDates, dv);
        };
        
        return true;
    },
    
    toggleWeekSelection: function(el, index) {
        var me          = this,
            cells       = me.cells,
            selectedCls = me.selectedCls,
            disabledCls = me.disabledCellCls,
            workDays    = me.workDays,
            selected, dayNo, firstDay;
        
        if ( index === undefined ) {
            index = me.getCellIndex( el.down('a').getAttribute('dateValue') );
        };
        
        if ( !me.disabled && !el.hasCls(disabledCls) ) {
            selected = el.hasCls(selectedCls);
            dayNo    = index % 7;
            firstDay = index - dayNo;
            
            // We're toggling only work week. If there's a need to toggle
            // whole week, adjust workDays to have values [0..6].
            if ( Ext.Array.contains(workDays, dayNo) ) {
                var i = firstDay + workDays[0],
                    l = firstDay + workDays[ workDays.length - 1 ];
                    
                for (; i <= l; i++ ) {
                    me.toggleDateSelection( cells.item(i), !selected );
                };
            };
        };
        
        return true;
    },
    
    toggleDateSelection: function(el, state, dv) {
        var me = this,
            selDates = me.selDates,
            selectedCls = me.selectedCls,
            disabledCls = me.disabledCellCls,
            selected, dv;
        
        if ( dv === undefined ) {
            dv = el.down('a').getAttribute('dateValue');
        };
        
        if ( !me.disabled && !el.hasCls(disabledCls) && dv ) {
            selected = state !== undefined ? !state : el.hasCls(selectedCls);
            
            if ( selected ) {
                Ext.Array.remove(selDates, dv);
            }
            else {
                Ext.Array.include(selDates, dv);
            };
            
            return el;
        };
        
        return undefined;
    },
    
    selectedUpdate: function(dates, active) {
        var me          = this,
            cells       = me.cells,
            selectedCls = me.selectedCls,
            activeCls   = me.activeCls,
            visible, cancelFocus;
        
        visible     = me.isVisible();
        cancelFocus = !me.focusOnSelect;
        
        cells.each( function(el) {
            var picker = this,
                dv;
            
            el.removeCls([activeCls, selectedCls]);
            
            dv = el.down('a').getAttribute('dateValue');
            
            if ( dv === active ) {
                picker.getEl().set({ 'aria-activedescendant': el.id });
                
                el.addCls(activeCls);
                
                if ( visible && !cancelFocus ) {
                    Ext.fly( el.down('a') ).focus(50);
                };
            };
            
            if ( Ext.Array.contains(dates, dv) ) {
                el.addCls(selectedCls);
            };
        }, me);
    },
    
    update: function(dates, forceRefresh) {
        var me = this,
            selDates,
            active = me.activeDate,
            newActive;
        
        if ( Ext.isArray(dates) ) {
            me.selDates = dates;
        };
        
        selDates = me.selDates || [];
        
        newActive = Ext.isDate(dates)       ? dates
                  :                           active
                  ;
        
        if ( me.rendered ) {
            var am = active    && active.getMonth(),
                ay = active    && active.getFullYear(),
                nm = newActive && newActive.getMonth(),
                ny = newActive && newActive.getFullYear();
                
            me.activeDate = newActive;

            if ( !forceRefresh && am == nm && ay == ny ) {
                me.selectedUpdate(selDates, newActive.getTime());
            }
            else {
                me.fullUpdate(newActive, active);
                me.selectedUpdate(selDates, newActive.getTime());
            };
        };
        
        return me;
    },
    
    beforeDestroy: function() {
        var me = this;
        
        if ( me.rendered ) {
            Ext.destroy(
                me.okBtn,
                me.cancelBtn,
                me.clearBtn
            );
            
            delete me.selDates;
        };
        
        me.callParent(arguments);
    }
});
                /*
 * Input field that allows multiple date values, including multiple contiguous ranges.
 *
 * Version 0.99, compatible with Ext JS 4.1.
 *  
 * Copyright (c) 2011-2012 Alexander Tokarev.
 *  
 * Usage: drop-in replacement for Ext.form.field.Date. See demo application
 * for more details.
 *
 * This code is licensed under the terms of the Open Source LGPL 3.0 license.
 * Commercial use is permitted to the extent that the code/component(s) do NOT
 * become part of another Open Source or Commercially licensed development library
 * or toolkit without explicit permission.
 * 
 * License details: http://www.gnu.org/licenses/lgpl.html
 */

Ext.define('Ext.ux.form.field.MultiDate', {
	extend: 'Ext.form.field.Date',
	alias:	'widget.multidatefield',
	
	alternateClassName: [
	    'Ext.form.field.MultiDate',
	    'Ext.form.MultiDateField',
	    'Ext.form.MultiDate'
	],
	
	requires: [ 'Ext.ux.picker.MultiDate' ],

	mixins: {
	    multivalue: 'Ext.ux.form.field.MultiValue'
	},

    /**
     * @cfg {String} okText OK button text.
     */
    okText: 'OK',
    
    /**
     * @cfg {String} cancelText Cancel button text.
     */
    cancelText: 'Cancel',
    	
    /**
     * @cfg {String} clearText 'Clear' button text.
     */
    clearText: 'Clear',

	/**
	 * @cfg {String} multiDisabledText
	 * Error text to display when multiple values are entered while multiValue is false.
	 */
	multiDisabledText: 'Multiple dates are not allowed',
	
	/**
	 * @cfg {String} invalidRangeText
	 * Error text to display when an invalid date range is entered.
	 */
	invalidRangeText: '{0} is not a valid date range',
	
	/**
	 * @cfg {String} invalidRangeEndsText
	 * Error text to display when range end is less than range start.
	 */
	invalidRangeEndsText: '{0} is invalid: start date must be earlier than end date',
	
    /**
     * @cfg {Int[]} workDays Array of 0-based week day numbers that represent work week
     * for given locale. Defaults to Monday-Friday.
     */
    workDays: [ 1, 2, 3, 4, 5 ],

    altFormats : "m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m/d|n/j",
    
    initComponent: function() {
        var me = this;
        
        me.callParent(arguments);
        
        // It's always turned off when multiValue is on
        if ( me.multiValue ) {
            me.showToday = false;
        };
    },
    
    initValue: function() {
        var me    = this,
            value = me.value;
        
        if ( value && Ext.isString(value) ) {
            me.setRawValue(value);
        }
        else if ( Ext.isDate(value) ) {
            me.setRawValue( me.formatDisplayValue(value) );
        }
        else {
            return;
        };
        
        me.validate();
    },
    
    setValue: function(value, isSubmit) {
        var me = this;
        
        if ( isSubmit ) {
            me.setSubmitValue(value);
        }
        else {
            me.callParent([value]);
        };
    },
    
    setSubmitValue: function(value) {
        var me = this,
            fmt = me.submitFormat,
            vsep, rsep, values, collapsed, text;
        
        vsep = new XRegExp(me.submitValueSeparator);
        rsep = new XRegExp(me.submitRangeSeparator);
        
        values = me.expandValues(value, fmt, vsep, rsep);
        
        if ( values && values.length ) {
            collapsed = me.collapseRange(values);
            text      = me.formatDisplay(collapsed);
            
            me.setRawValue(text);
        }
        else {
            me.setRawValue('');
        };
    },
    
    getSubmitValue: function() {
        var me = this,
            values;
        
        values = me.getRawValue();
        
        return me.formatSubmit(values);
    },

    createPicker: function() {
        var me = this,
            format = Ext.String.format;
            
        if ( !me.multiValue ) {
            return me.callParent(arguments);
        };
        
        return Ext.create('Ext.picker.MultiDate', {
            pickerField: me,
            ownerCt: me.ownerCt,
            renderTo: document.body,
            floating: true,
            hidden: true,
            focusOnShow: true,
            minDate: me.minValue,
            maxDate: me.maxValue,
            disabledDatesRE: me.disabledDatesRE,
            disabledDatesText: me.disabledDatesText,
            disabledDays: me.disabledDays,
            disabledDaysText: me.disabledDaysText,
            format: me.format,
            showToday: me.showToday,
            startDay: me.startDay,
            okText: me.okText,
            cancelText: me.cancelText,
            clearText: me.clearText,
            workDays: Ext.Array.sort(me.workDays, function(a, b) { return a - b }),
            minText: format(me.minText, me.formatDate(me.minValue)),
            maxText: format(me.maxText, me.formatDate(me.maxValue)),
            listeners: {
                scope: me,
                select: me.onSelect
            }
        });
    },
    
    getErrors: function(values) {
        var me = this,
            multi = me.multiValue,
            vsep = me.valueSeparatorRE,
            rsep = me.rangeSeparatorRE,
            errors = [],
            matches, range, isValid, dt;
        
        if ( values === null || values.length < 1 ) {
            if ( !me.allowBlank ) {
                errors.push(me.blankText);
            };
            
            return errors;
        };
        
        matches = me.splitValues(values, vsep);
        
        if ( !multi && matches.length > 1 ) {
            errors.push(me.multiDisabledText);
        };
        
        MATCHES:
        for ( var i = 0, l = matches.length; i < l; i++ ) {
            var match = matches[i];
        
            // Try to validate the match as a single date; it may just be one
            dt = me.parseDate(match);
            
            if ( Ext.isDate(dt) ) {
                isValid = me.validateDate(match);
            }
            else if ( !rsep.test(match) ) {
                isValid = Ext.String.format(me.invalidText, match, me.format);
            }
            else {
                range = me.splitValues(match, rsep);
                
                if ( !multi && range.length > 1 ) {       // Got date range
                    errors.push(me.multiDisabledText);
                };
                    
                isValid = me.validateRange(range);
            };

            if ( isValid !== true ) {
                errors.push(isValid);
            };
        };
        
        return errors;
    },
    
    splitValues: function(values, regex) {
        var me = this;
        
        return Ext.isString(values) &&
               regex.source !== '' && values.match(regex)   ? values.split(regex)
             :                                                [ values ]
             ;
    },

    onExpand: function() {
        var me = this,
            text, values;
            
        if ( !me.multiValue ) {
            return me.callParent(arguments);
        };
        
        text = me.getRawValue();

        // We don't care for invalid input
        if ( me.isValid() ) {
            values = me.expandValues( text );
            me.picker.setValue( values );
        }
        else if ( text === '' ) {
            me.clearInvalid();
        };
    },
    
    onSelect: function(picker, dates) {
        var me = this,
            collapsed, text;
        
        if ( !me.multiValue ) {
            return me.callParent(arguments);
        };
        
        collapsed = me.collapseRange(dates);
        text      = me.formatDisplay(collapsed);
        
        me.setRawValue(text);
        
        me.fireEvent('select', me, text);
        
        me.collapse();
    },
    
    parseDate: function(value, format) {
        var me = this,
            dt;
        
        if ( format && (dt = me.safeParse(value, format)) ) {
            return dt;
        };
        
        return me.callParent([value]);
    },
    
    validateDate: function(value) {
        var me = this,
            dt;
        
        dt = me.parseDate(value);
        
        return Ext.isDate(dt) || Ext.String.format(me.invalidText, value, me.format);
    },
    
    validateRange: function(range) {
        var me = this,
            rsep = me.displayRangeSeparator,
            isDate = Ext.isDate,
            getElapsed = Ext.Date.getElapsed,
            format = Ext.String.format,
            start, end,
            isValid = false;
        
        try {
            start   = me.parseDate( range[0] );
            end     = me.parseDate( range[1] );
            
            isValid = !!(isDate(start) && isDate(end) && start.getTime() <= end.getTime());
        } catch (e) {};
        
        if ( !isDate(start) || !isDate(end) ) {
            return format(me.invalidRangeText, range[0] + rsep + range[1] );
        };
        
        if ( start.getTime() > end.getTime() ) {
            return format(me.invalidRangeEndsText, me.formatDisplayRange(range, rsep) );
        };
        
        if ( (isValid = me.validateDate(range[0])) !== true ) {
            return isValid;
        };
        
        if ( (isValid = me.validateDate(range[1])) !== true ) {
            return isValid;
        };
        
        return true;
    },
    
    formatSubmit: function(values, rsep, vsep) {
        var me = this,
            multi = me.multiValue,
            valsep = me.valueSeparatorRE,
            ransep = me.rangeSeparatorRE,
            items, isStr, doesMatch, dt;
        
        items = me.splitValues(values, valsep);
        
        for ( var i = 0, l = items.length; i < l; i++ ) {
            var item = items[i],
                vr;
            
            if ( Ext.isDate( me.parseDate(item) ) ) {
                items[i] = me.formatSubmitValue(item);
            }
            else {
                vr = me.splitValues(item, ransep);
                
                items[i] = vr.length > 1 ? me.formatSubmitRange(vr, rsep || me.submitRangeSeparator)
                         :                 me.formatSubmitValue(vr)
                         ;
            };
        };
        
        values = items.join(vsep || me.submitValueSeparator);
        
        return values;
    },
    
    formatSubmitValue: function(value) {
        var me = this,
            fmt = me.submitFormat || me.format,
            dt, res;
        
        try {
            dt  = Ext.Date.clearTime( me.parseDate(value) );
            res = Ext.Date.format(dt, fmt);
        } catch (e) {};
        
        return Ext.isString(res) ? res : '';
    },
    
    formatDisplayValue: function(value) {
        var me = this,
            fmt = me.format,
            dt, res;
        
        try { res = Ext.Date.format(value, fmt); } catch (e) {};
        
        return Ext.isString(res) ? res : '';
    },
    
    expandValues: function(text, format, vSeparator, rSeparator) {
        var me   = this,
            vsep = vSeparator || me.valueSeparatorRE,
            rsep = rSeparator || me.rangeSeparatorRE,
            values, dt,
            result = [];
        
        if ( text === '' || text === null ) {
            return [];
        };
        
        values = me.splitValues(text, vsep);
        
        for ( var i = 0, l = values.length; i < l; i++ ) {
            var value = values[i];
            
            dt = me.parseDate(value, format);
            
            if ( Ext.isDate(dt) ) {
                result.push(dt);
            }
            else {
                var range = me.splitValues(value, rsep);
                
                // Ugh. What an ugliness.
                result = [].concat( result, 
                                    range.length > 1 ? me.expandRange(range, format)
                                  :                    me.parseDate(range[0])
                                  );
            };
        };
        
        return result;
    },
    
    expandRange: function(range, format) {
        var me = this,
            start, end,
            result = [];
        
        start = me.parseDate( range[0], format );
        end   = me.parseDate( range[1], format );
        
        if ( !Ext.isDate(start) || !Ext.isDate(end) || Ext.Date.getElapsed(start, end) < 0 ) {
            return [];
        };
        
        dt = start;
        
        for ( var dt = start; dt <= end; dt = Ext.Date.add(dt, Ext.Date.DAY, 1) ) {
            result.push(dt);
        };
        
        return result;
    },

	/**
	 * @private
	 * Collapses item ranges. The code is adapted from Perl module Range::Object
	 */
	collapseRange: function(data) {
		var me = this,
			range = Ext.clone(data),
			first, last,
			result = [];
		
		if ( Ext.isEmpty(data) ) {
		    return result;
		};
		
		range.sort( function(a, b) { return a.getTime() - b.getTime() } );
		
		ITEM:
		for ( var i = 0, l = range.length; i < l; i++ ) {
			var item = range[i];
			
			// If first is defined, it means range has started
			if ( first === undefined ) {
				first = last = item;
				continue ITEM;
			};
			
			// If last immediately preceeds item in range,
			// item becomes next last
			if ( me.nextInRange(last, item) ) {
				last = item;
				continue ITEM;
			};
			
			// If item doesn't follow last and last is defined,
			// it means that current contiguous range is complete
			if ( !me.equalValues(first, last) ) {
				result.push( [first, last] );
				first = last = item;
				continue ITEM;
			};
			
			// If last wasn't defined, range was never contiguous
			result.push( first );
			first = last = item;
		};
		
		// We're here when last item has been processed
		if ( me.equalValues(first, last) ) {
			result.push( first );
		}
		else {
			result.push( [first, last] );
		};
		
		return result;
	},
	
	nextInRange: function(first, last) {
		var dt;
		
		dt = Ext.Date.add(first, Ext.Date.DAY, 1);
		
		return !!(dt.getTime() === last.getTime());
	},
	
	equalValues: function(first, last) {
		return first.getTime() === last.getTime();
	}
});
                Ext.define('CenterGrid', {
    _addTotalStories: function(data) {
        var totalStories = _.reduce(data, function(sum, el) {
            return sum + el.data;
        }, 0);

        data.push({ name: 'Total Stories Completed', data: totalStories });
    },

    _addAverageDays: function(data, records) {
        var totalDaysExclusions = _.reduce(records, function(sum, el) {
            return sum + el.DaysInProgressExclusions;
        }, 0);

        var average = totalDaysExclusions / records.length;
        var averageRounded = Math.round(average * 100) / 100;

        data.push({ name: 'Average Number of Days In Progress', data: averageRounded });
    },

    _create: function(App) {
        return Ext.create('Rally.ui.grid.Grid', {
                store: App.centerGridStore,
                showPagingToolbar: false,
                listeners: {
                    load: function(myStore, myData, success) {
                        console.log("I'm here!");
                    }
                },
                columnCfgs: [{
                    text: '',
                    dataIndex: 'name',
                },
                {
                    text: '',
                    dataIndex: 'data'
                }]
            });
    }
});
                Ext.define('Chart', {
    _recordsToChartData: function(records) {
        //TODO: this method is extremely ugly.  Maybe there is a nice functional way to do it?
        var dict = {};
        for (var i = 0; i < records.length; i++) {
            var exclusions = records[i].DaysInProgressExclusions

            var m = 1;
            var MAX = 20;   //as the function is written, this should be a multiple of 5
            while (m * 5 <= MAX) {
                var multiple = 5 * m;
                if (exclusions <= multiple) {
                    var begin = (multiple == 5) ? 0 : multiple - 4;

                    var name = 'Stories ' + begin + ' to ' + multiple;
                    this._populateDictionary(dict, multiple, name);
                    break;
                }
                m++;
            }
            if (m * 5 > MAX) {
                var name = 'More than ' + MAX;
                var index = MAX + 1;    //ensure this is the largest key in the dictionary
                this._populateDictionary(dict, index, name);
            }
        }

        var data = [];
        for (var prop in dict) {
            data.push(dict[prop]);
        }

        //TODO: data may have to be sorted...for over the object properties may not be in any guaranteed order?
        return data;
    },

    _populateDictionary: function(dict, index, name) {
        if (dict[index] == undefined) {
            dict[index] = { 'name': name, 'data': 1 };
        } else {
            var obj = dict[index];
            obj.data++;
        }
    },

    _create: function(App){
        return Ext.create('Ext.chart.Chart', {
                renderTo: Ext.getBody(),
                width: 500,
                height: 350,
                animate: true,
                store: App.chartStore,
                theme: 'Base:gradients',
                legend: {
                    visible:true,
                    position: 'left',
                    labelFont: '12px Arial'
                },
                series: [{
                    type: 'pie',
                    angleField: 'data',
                    showInLegend: true,
                    tips: {
                        trackMouse: true,
                        width: 140,
                        height: 28,
                        renderer: function(storeItem, item) {
                            // calculate and display percentage on hover
                            var total = 0;
                            store.each(function(rec) {
                                total += rec.get('data');
                            });
                            this.setTitle(storeItem.get('name') + ': ' + Math.round(storeItem.get('data') / total * 100) + '%'); 
                        }
                    },
                    highlight: {
                        segment: {
                            margin: 20
                        }
                    },
                    label: {
                        field: 'name',
                        display: 'rotate',
                        contrast: true,
                        font: '12px Arial'
                    }
                }]
            });
    }
});
                Ext.define('MainGrid', {
    _create: function(App) {
        return Ext.create('Rally.ui.grid.Grid', {
                store: App.customGridStore,
                listeners: {
                    load: function(myStore, myData, success) {
                        console.log("I'm here!");
                    }
                },
                columnCfgs: [{
                    flex: 1,
                    text: 'ID',
                    dataIndex: 'FormattedID',
                }, 
                {
                    flex: 1,
                    text: 'Name',
                    dataIndex: 'Name',
                },
                {
                    flex: 1,
                    text: 'Days In Progress', 
                    dataIndex: 'DaysInProgress'
                },
                {
                    flex: 1,
                    text: 'Days In Progress (w/ Exclusions)', 
                    dataIndex: 'DaysInProgressExclusions'
                },
                {
                    flex: 1,
                    text: 'In Progress Date',
                    dataIndex: 'InProgressDate',
                },
                {
                    flex: 1,
                    text: 'Accepted Date',
                    dataIndex: 'AcceptedDate',
                }]
            });
    }
});
                Ext.define('CustomModel', {
    extend: Ext.ModelManager.getModel('User Story'),
    fields: [
        {name: 'DaysInProgress',  type: 'int'},
        {name: 'DaysInProgressExclusions', type: 'int'}
    ],
});

Ext.define('MainStore', {
    _create: function(App, storeFilters){
        return Ext.create('Rally.data.wsapi.Store', {
                //model: 'CustomModel',
                model: 'User Story',
                autoLoad: true,
                filters: storeFilters,
                listeners: {
                    load: function(myStore, myData, success) {
                        var records = _.map(myData, function(record) {

                            function calculateDateDifference(record){
                                var inProgressDate = record.get('InProgressDate');
                                var acceptedDate = record.get('AcceptedDate');

                                //http://stackoverflow.com/questions/2627473/how-to-calculate-the-number-of-days-between-two-dates-using-javascript
                                var oneDay = 24*60*60*1000; // hours*minutes*seconds*milliseconds
                                //var diffDays = Math.round(Math.abs((inProgressDate.getTime() - acceptedDate.getTime())/(oneDay)));
                                var diffDays = Math.ceil(Math.abs((inProgressDate.getTime() - acceptedDate.getTime())/(oneDay)));
                                return diffDays;
                            }

                            function calculateExclusions(record, context) {
                                var field = Ext.getCmp('multiDateField');
                                var inProgressDate = record.get('InProgressDate');
                                var acceptedDate = record.get('AcceptedDate');

                                var inProgressDateString = inProgressDate.getFullYear() + '-'
                                    + ('0' + (inProgressDate.getMonth()+1)).slice(-2) + '-'
                                    + ('0' + inProgressDate.getDate()).slice(-2);

                                var acceptedDateString = acceptedDate.getFullYear() + '-'
                                    + ('0' + (acceptedDate.getMonth()+1)).slice(-2) + '-'
                                    + ('0' + acceptedDate.getDate()).slice(-2);


                                var dateRange = inProgressDateString + "/" + acceptedDateString;
                                var dateArray = field.expandValues(dateRange, 'Y-m-d', ';', '/');

                                var excluded;
                                if (context.checkboxValue) {
                                    var weekendDays = _.filter(dateArray, function(date) {
                                        var day = date.getDay();
                                        return day == 0 || day == 6;
                                    });

                                    var weekendDayStrings =  _.map(weekendDays, function(date) {
                                        return date.toString();
                                    });

                                    excluded = _.uniq(_.union(weekendDayStrings, context.excludedDates));
                                } else {
                                    excluded = context.excludedDates;
                                }

                                var dateStringArray =  _.map(dateArray, function(date) {
                                    return date.toString();
                                });

                                var intersection = _.intersection(dateStringArray, excluded); //run intersection in string arrays instead of date arrays

                                var exclusions = calculateDateDifference(record) - intersection.length;
                                return exclusions >= 0 ? exclusions : 0;
                            }

                            return Ext.apply({              
                                DaysInProgress: calculateDateDifference(record),
                                DaysInProgressExclusions: calculateExclusions(record, App)
                            }, record.getData());
                        }, App);
                        
                        //try adding fields to model?
                        // if (records.length <= 0) {
                        //     //myStore.model.addField('DaysInProgress');
                        //     myStore.model.addField({ name: 'DaysInProgress', type: 'int' });
                        //     //myStore.model.addField('DaysInProgressExclusions');
                        //     myStore.model.addField({ name: 'DaysInProgressExclusions', type: 'int' });
                        // }
                        App._loadGrid(myStore, records);
                        App._createChart(records);
                    },
                    scope: App
                },
                fetch: ['FormattedID', 'Name', 'AcceptedDate', 'InProgressDate', 'RevisionHistory', 'Revisions', 'Description', 'User', 'Project']
            });
    }
});
                Ext.require([
    'Ext.ux.form.field.MultiDate'
]);

Ext.define('MultiDateCalendarPanel', {
    _create: function(App){
        Ext.tip.QuickTipManager.init();
        var store;

        /*
         *  Creates a panel with a multi date calendar, an 'exclude weekends' checkbox, and a 'Get Report' button
         */
        return Ext.create('Ext.form.Panel', {           
            id: 'formPanel',
            
            layout: 'vbox',
            frame: false,
            border: false,
            
            defaults: {
                autoScroll: true,
                bodyPadding: 8,
                listeners: {
                    specialkey: function(form, event) {
                        if (event.getKey() === event.ENTER) {
                            form.up().down('#validateButton').handler();
                        };
                    }
                }
            },
            
            items: [{
                    xtype: 'multidatefield',
                    id: 'multiDateField',
                    fieldLabel: 'Exclusions',
                    allowBlank: true,
                    multiValue: true,
                    submitFormat: 'Y-m-d',
                    submitRangeSeparator: '/',
                }, 
                {
                    xtype: 'fieldcontainer',
                    fieldLabel: 'Exclude Weekends',
                    defaultType: 'checkboxfield',
                    items: [
                        {
                            name      : 'weekendCheckbox',
                            inputValue: '1',
                            checked   : true,
                            id        : 'weekendCheckbox'
                        }
                    ]
                },
                {
                xtype: 'button',
                id:    'validateButton',
                text:  'Get Report',
                scope: App,
                handler: function() {
                    var form, field;
                    
                    form  = Ext.getCmp('formPanel').getForm();
                    field = Ext.getCmp('multiDateField');
                    
                    if ( form.isValid() ) {
                        var values = form.getValues();
                        var valuesString = field.getSubmitValue();
                        var valuesArray = field.expandValues(valuesString, 'Y-m-d', ';', '/');

                        App.checkboxValue = Ext.getCmp('weekendCheckbox').getValue();

                        App.excludedDates =  _.map(valuesArray, function(date) {
                            return date.toString();
                        });                     

                        App._runReport();                    
                    }
                    else {
                        console.log("The form is invalid.");
                        //alert to the screen?
                        App._runReport(); 
                    };
                }
            }],
            
            renderTo: Ext.getBody()
        });
    }
});

            Rally.launchApp('CustomApp', {
                name:"exclusions",
	            parentRepos:""
            });

        });
    </script>


    <style type="text/css">
        .app {
  /* Add app styles here */
}

    </style>
    <style type="text/css">
        .ux-datepicker-active {
  cursor: pointer;
  color: #000;
  background: repeat-x left top;
  background-color: #ddecfe;
}
.ux-datepicker-inner,
.ux-datepicker-inner td,
.ux-datepicker-inner th {
  border-collapse: separate;
}
table.ux-datepicker-inner {
  width: 100%;
  table-layout: fixed;
}
table.ux-datepicker-inner th {
  width: 25px;
  height: 19px;
  color: #233d6d;
  font: normal 10px tahoma, arial, verdana, sans-serif;
  text-align: right;
  border-bottom: 1px solid #b2d1f5;
  border-collapse: separate;
  background-color: #dfecfb;
  background-image: linear-gradient(top, #edf4fd, #cde1f9);
  cursor: default;
  padding: 0;
}
table.ux-datepicker-inner th span {
  display: block;
  padding-right: 7px;
}
table.ux-datepicker-inner td {
  border: 1px solid;
  height: 17px;
  text-align: right;
  border-color: #FFF;
  padding: 0;
}
table.ux-datepicker-inner a {
  padding-right: 4px;
  display: block;
  zoom: 1;
  font: normal 11px tahoma, arial, verdana, sans-serif;
  color: #000;
  text-decoration: none;
  text-align: right;
}
table.ux-datepicker-inner .ux-datepicker-active {
  cursor: pointer;
  color: #000;
  border: 1px solid;
  border-color: #ff0000;
}
table.ux-datepicker-inner .x-datepicker-selected a {
  background: repeat-x left top;
  background-color: #dae5f3;
  border: 1px solid #8db2e3;
}
table.ux-datepicker-inner .x-datepicker-selected span {
  font-weight: 700;
}
table.ux-datepicker-inner .x-datepicker-today a {
  border: 1px solid;
  border-color: #8B0000;
}
table.ux-datepicker-inner .x-datepicker-prevday a,
table.ux-datepicker-inner .x-datepicker-nextday a {
  text-decoration: none!important;
  color: #aaa;
}
table.ux-datepicker-inner a:hover,
table.ux-datepicker-inner .x-datepicker-disabled a:hover {
  text-decoration: none!important;
}
table.ux-datepicker-inner .u-datepicker-disabled a {
  cursor: default;
  background-color: #eee;
  color: #bbb;
}
.x-item-disabled .ux-datepicker-inner a:hover {
  background: none;
}

    </style>
</head>
<body>
</body>
</html>
